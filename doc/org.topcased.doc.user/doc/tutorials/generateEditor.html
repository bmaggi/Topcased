<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-us" xml:lang="en-us">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
<meta name="copyright" content="(C) Copyright 2005" />
<meta name="DC.rights.owner" content="(C) Copyright 2005" />
<meta content="topic" name="DC.Type" />
<meta name="DC.Title" content="Generate an Editor" />
<meta content="XHTML" name="DC.Format" />
<meta content="mfgeneditor" name="DC.Identifier" />
<meta content="en-us" name="DC.Language" />
<link href="../css/visual.css" type="text/css" rel="stylesheet" />
<title>MODELING FRAMEWORK - Tutorial : Generate an Editor</title>
</head>
<body id="mfgeneditor"><a name="mfgeneditor"><!-- --></a>


	<h1 class="topictitle1">Generate an Editor</h1>

	
	
	<div id="container"><a name="container"><!-- --></a>
		<p><a href="#mfgeneditor__title1">1. Creation of an Ecore Metamodel</a></p>

		<p><a href="#mfgeneditor__title1.1">1.1 Configuration and generation of the EMF tree structure editor</a></p>

		<p><a href="#mfgeneditor__title1.2">1.2 Configuration</a></p>

		<p><a href="#mfgeneditor__title1.3">1.3 Generation</a></p>

		<p><a href="#mfgeneditor__title2">2. Creation of the configurator for the graphical editor</a></p>

		<p><a href="#mfgeneditor__title2.1">2.1 The Editor Configurator file</a></p>

		<p><a href="#mfgeneditor__title2.2">2.2 The Diagram Configurator file</a></p>

		<p><a href="#mfgeneditor__title3">3. Generation of the graphical editor and customizations</a></p>

		<p><a href="#mfgeneditor__title3.1">3.1 Icons</a></p>

		<p><a href="#mfgeneditor__title3.2">3.2 Templates</a></p>

		<p><a href="#mfgeneditor__title3.3">3.3 EditPart customization</a></p>

		<p><a href="#mfgeneditor__title3.4">3.4 Figure customization</a></p>

		<p><a href="#mfgeneditor__title3.5">3.5 TODO tags</a></p>

		<p><a href="#mfgeneditor__title3.6">3.6 The diagram.graphconf file</a></p>

		
		
		
		<p class="h2">Introduction :</p>

		
		<p>The document is a user manual that explains the generation process : how from a starting metamodel, we can generate a graphical editor. The process takes a few steps :</p>

		<br /><ul>
			<li>creation of the Ecore Metamodel (use the graphical Ecore editor or the EMF tree structure Ecore editor)</li>

			<li>generation of the EMF tree structure editor</li>

			<li>creation of the configurator files for the graphical editor with the EMF tree structure Configurators editor.</li>

			<li>generation of the graphical editor and its diagrams, and customization.</li>

		</ul>

		
		<p class="h2" id="mfgeneditor__title1"><a name="mfgeneditor__title1"><!-- --></a>1. Creation of an Ecore Metamodel</p>

		<p>Create an "Empty EMF project". Give a name like <strong>org.topcased.xxx</strong> where <strong>xxx</strong> is the name of the metamodel.</p>

		<img src="images/generateEditor/empty_EMF_project.jpg" alt="empty_EMF_project" />
		<p>Then, you can create an Ecore model from the tree structure EMF tree structure Ecore editor : select "New &gt; Other...", and "Example EMF Model Creation Wizards &gt;
			Ecore Model". Create a new folder (model) that will contain the newly created Ecore model.
		</p>

		<img src="images/generateEditor/new_ecore_model.jpg" alt="new_ecore_model" />
		<p>Select "EPackage" as the root model object to create.</p>

		<img src="images/generateEditor/select_model_object.jpg" alt="select_model_object" />
		<p>Then you can make your model, create EClasses, EReferences, EAttributes, ...</p>

		<p><strong>Remark 1 :</strong> you have other ways to get your Ecore metamodel. You can use the graphical Ecore Editor of Topcased or import it from a Rose class model.</p>

		<div class="p"><strong>Remark 2 :</strong> the root EPackage attributes must be filled with the following values :
			<br /><ul>
				<li>Name : "<strong>xxx</strong>"</li>

				<li>NsPrefix : "<strong>xxx</strong>"</li>

				<li>NsURI : enter something like "http://www.topcased.org/1.0/<strong>xxx</strong>" so that you get a unique URI for a given metamodel of a given version.</li>

			</ul>

		</div>

		
		<p class="h3" id="mfgeneditor__title1.1"><a name="mfgeneditor__title1.1"><!-- --></a>1.1 Configuration and generation of the EMF tree structure editor</p>

		<p>The first step is to create the <strong>xxx.genmodel</strong> file that will configure what will be generated at the creation of the tree structure editor.</p>

		<p><strong>Remark :</strong> if you have chosen to create your Ecore metamodel from a Rose class model, the <strong>xxx.genmodel</strong> file is automatically created, you have just to customize it.</p>

		<img src="images/generateEditor/select_model_importer.jpg" alt="select_model_importer" />
		<p>Select "New &gt; Other...", and "Eclipse Modeling Framework &gt; EMF Model". Create the file <strong>xxx.genmodel</strong> in the same folder as the <strong>xxx.ecore</strong> file. Then select
			"EMF core model" as the Model Importer and reference the <strong>xxx.ecore</strong> file as the model file in the next page wizard.
		</p>

		
		<p class="h3" id="mfgeneditor__title1.2"><a name="mfgeneditor__title1.2"><!-- --></a>1.2 Configuration</p>

		<br /><ul>
			<li><strong>Configuration of the GenModel (root element) :</strong>
				<br /><ul>
					<li>You can leave the default options (the generation will generate two more plugins : a plugin "edit" and a plugin "editor") or modify some properties to generate
						all classes in only one plugin. If you want to avoid generating two more plugins, delete the "edit" and "editor" occurrences among the properties ("Edit directory"
						and "Editor directory").
					</li>

				</ul>

			</li>

			<li><strong>Configuration of a GenPackage :</strong>
				<br /><ul>
					<li>Base Package : value = "org.topcased"</li>

				</ul>

			</li>

			<li><strong>Configuration of a GenClass :</strong>
				<br /><ul>
					<li>Label Feature : select the attribute that will be displayed as the label. This feature will be used to show the label that best represent the model object.
						In general, select the "name" attribute. <strong>The type of the feature should be a String</strong>
					</li>

				</ul>

			</li>

			<li><strong>Configuration of a GenFeature :</strong>
				<br /><ul>
					<li>Property Type :
						<br /><ul>
							<li>Editable : the value is modifiable by the user</li>

							<li>ReadOnly : the value is available in read only</li>

							<li>None : the value won't be displayed in the Properties View</li>

						</ul>

					</li>

					<li>PropertyCategory : affect the property to a category. Each property of a model object is contained by a category. If none is defined, a default category "Misc" is created.</li>

					<li>Property Description : describe the property. The text will be displayed at the bottom of the Eclipse environment in a status bar.</li>

					<li>Property Filter Flags : it is used to filter some properties. Thus, we can provide two views : a "Simple" view (the value is left empty) and an "Advanced" one
						(the value is set to "org.eclipse.ui.views.properties.expert"). The user can activate the "Advanced" view (by clicking on the icon "Show Advanced Properties").
					</li>

				</ul>

			</li>

		</ul>

		
		<p class="h3" id="mfgeneditor__title1.3"><a name="mfgeneditor__title1.3"><!-- --></a>1.3 Generation</p>

		<p>To generate the tree structure editor, open the <strong>xxx.genmodel</strong> file and right click on the GenModel element and select "Generate All".</p>

		<img src="images/generateEditor/generate_all.jpg" alt="generate_all" />
		
		<p class="h2" id="mfgeneditor__title2"><a name="mfgeneditor__title2"><!-- --></a>2. Creation of the configurators for the graphical editor</p>

		<p>Once you have generated the tree structure editor, let us configure a more convivial editor : a graphical editor.</p>

		<p>The first step is to create the necessary configurator files. The configurator files describe what the editor will look like, which diagrams will be available and what will be
			displayed in each diagram. The configuration of a graphical editor consists in describing several configuration files :
		</p>

		<br /><ul>
			<li>an <strong>editor configuration</strong> file that will describe the editor plugin</li>

			<li>a <strong>diagram configuration</strong> file for each diagram</li>

		</ul>

		
		<p class="h3" id="mfgeneditor__title2.1"><a name="mfgeneditor__title2.1"><!-- --></a>2.1 The Editor Configurator file</p>

		<p>Select "<strong>New &gt; Others...</strong>", and then "<strong>Topcased &gt; Topcased Configurators &gt; Editorconfigurator Model</strong>".
			<img src="images/generateEditor/selectWizard.jpg" alt="selectWizard" />
			The root model object must be "Editor Configuration". When you have finished the wizard, the editor is opened. The configurator model only contains the root element "Editor
			Configuration". The editor configurator file is quite simple. It contains only one model object, an EditorConfiguration with a few properties. You can define here common
			properties of the generated editor plugin :
		</p>

		<br /><ul>
			<li>EditorConfiguration
				<br /><ul>
					<li><strong>name</strong> : EString. The name that will be used for display : "SAM Editor"</li>

					<li><strong>projectName</strong> : EString. The project name that will be created : "org.topcased.modeler.sam"</li>

					<li><strong>genModel</strong> : GenModel. A reference to the GenModel file associated with the metamodel</li>

					<li><strong>pluginVersion</strong> : EString. The version of the generated plugin : by default it takes the same version of the EditorConfiguratorPlugin</li>

					<li><strong>forceOverwrite</strong> : EBoolean <var class="varname">(since 0.9.0)</var>. Specify whether the non java files that are generated (plugin.xml, MANIFEST.MF, ...) should
						be overwritten or not
					</li>

					<li><strong>organizeImports</strong> : EBoolean <var class="varname">(since 0.9.0)</var>. Specify whether at the end of the generation process, an "Organize Imports" should be
						automatically done on the generated classes.
					</li>

				</ul>

			</li>

		</ul>

		
		<p class="h3" id="mfgeneditor__title2.2"><a name="mfgeneditor__title2.2"><!-- --></a>2.2 The Diagram Configurator file</p>

		<p>Select "<strong>New &gt; Others...</strong>", and then "<strong>Topcased &gt; Topcased Configurators &gt; Diagramconfigurator Model</strong>".
			<img src="images/generateEditor/selectWizard.jpg" alt="selectWizard" />
			The root model object must be "Diagram Configuration". When you have finished the wizard, the editor is opened. The configurator model only contains the root element
			"Diagram Configuration".
		</p>

		<p> Then, you will have to specify the metamodel file you will work with. Indeed, the objects we will create will depends on the model objects of the metamodel we have created.
			When your new empty configurator file is open, you can do this by right clicking on the editing window and selecting "Load Resource..." : then you have to select to
			corresponding <strong>xxx.genmodel</strong> file.
		</p>

		<p> The diagram configurator file is more complete. Indeed, it is used to configure all graphical objects used in the diagram, the associated model objects and the Palette of
			the diagram. We advise you to edit the different part of the configurator in the following order :
		</p>

		
		<p class="h4">2.2.1 Diagram Configuration</p>

		<p> This is the root model object of your diagram configurator. You can define here common properties of the generated diagram plugin and furthermore, you will reference here the
			loaded Genmodel file.
		</p>

		<br /><ul>
			<li>DiagramConfiguration
				<br /><ul>
					<li><strong>id</strong> : EString. The diagram ID property will define the name of the plugin that will be generated. If you change it to be the same as the projectName of the
						editor configuration, then all the files will be generated in this plugin. However, the common non java files that will be generated will not be merged. You will
						have to complete them by hand. This String should not contain any space : "org.topcased.modeler.uml.sequencediagram".
					</li>

					<li><strong>editorId</strong>	: EString <var class="varname">(since 0.9.0)</var>. Reference the editor Id generated for the editor. Generally the id has the following syntax :
						[projectName].editor.[Prefix]Editor where "projectName" is the property defined in the editor configuration and "Prefix" is the property defined in the GenModel.
						You can easily retrieve this Id in the plugin.xml file generated by the editor configuration.
					</li>

					<li><strong>genModel</strong> : GenModel. Reference the genModel file associated with the metamodel.</li>

					<li><strong>name</strong> : EString. The diagram name : "Sequence Diagram".</li>

					<li><strong>package</strong> : EString. The java package name that will contains generated classes relatives to this diagram : "systdiagram".</li>

					<li><strong>prefix</strong> : EString. A prefix used in the generated common classes of the diagram : "Syst".</li>

					<li><strong>layout</strong> : LayoutType. Define the type of Layout used todisplay the children elements.</li>

					<li><strong>defaultBackgroundColor</strong> : Color. Specify the default background color.</li>

					<li><strong>defaultForegroundColor</strong> : Color. Specify the default foreground color.</li>

					<li><strong>defaultFont</strong> : Font. Specify the default font.</li>

					<li><strong>palette</strong> &gt; PaletteConfiguration. Define the palette that will be associated with the diagram.</li>

					<li><strong>* parts</strong> &gt; PartConfiguration. Contains all the partConfiguration that should be available in the diagram.</li>

					<li><strong>* objects</strong> &gt; ObjectConfiguration. Contains all the objectConfiguration that should be referenced by the PartConfiguration of the diagram.</li>

					<li><strong>Template Root Object</strong> : EObject <var class="varname">(since 0.9.0)</var>. Describe the model object that should be root model object when a new Diagram is created.
						This is the model object that you choose when you create a new model with the EMF generated editor. This object will be used to create the template files.
					</li>

					<li><strong>Force Overwrite</strong> : EBoolean <var class="varname">(since 0.9.0)</var>. Specify whether the non java files that are generated (plugin.xml, MANIFEST.MF, ...) should
						be overwritten or not.
					</li>

					<li><strong>Organize Imports</strong> : EBoolean <var class="varname">(since 0.9.0)</var>. Specify whether at the end of the generation process, an organize imports should be
						automatically done on the generated classes.
					</li>

					<li><strong>Overwrite Graph Conf</strong> : EBoolean <var class="varname">(since 0.9.0)</var>. Specify whether the diagram.graphconf file that is generated should be overwritten or not.</li>

				</ul>

			</li>

		</ul>

		
		<p class="h4">2.2.2 ObjectConfiguration, ModelObjectConfiguration and SimpleObjectConfiguration</p>

		<p>There are two types of ObjectConfiguration. This element will describe the model representation defined at the DiagramConfiguration level.</p>

		<p>A ModelObjectConfiguration will be linked with a model object (that will be referenced by its GenClass). You will be able to specify one or several DiagramConfiguration that
			can be associated with this model object through a DiagramReference.
		</p>

		<p>A SimpleObjectConfiguration will not be linked with any model object. It will be then referenced by a PartConfiguration to represent only a graphical element.</p>

		<br /><ul>
			<li>ModelObjectConfiguration
				<br /><ul>
					<li><strong>genClass</strong> : GenClass. Reference to the GenClass of the model object.</li>

					<li><strong>* diagrams</strong> &gt; DiagramReference. Specify if the current diagram may be created into this ModelObjectConfiguration.</li>

				</ul>

			</li>

		</ul>

		<br /><ul>
			<li>SimpleObjectConfiguration (an ObjectConfiguration that is not associated with a model object)
				<br /><ul>
					<li><strong>name</strong> : String. An identifier for the objectConfiguration that will be used to generate the EditPart and the Figure.</li>

				</ul>

			</li>

		</ul>

		
		<p class="h4">2.2.3 DiagramReference</p>

		<p>The DiagramReference is used to indicate that a diagram will be associated with the model object referenced by the container ModelObjectConfiguration. Then you will be able to
			create new diagrams from this object. A same diagram may be associated with several ModelObjectConfiguration, and each diagram must be associated with at least one
			ModelObjectConfiguration.
		</p>

		<br /><ul>
			<li>DiagramReference
				<br /><ul>
					<li><strong>diagram</strong> : DiagramConfiguration. The corresponding diagramConfiguration.</li>

					<li><strong>lowerBound</strong> : EInt. Minimal diagrams number that can be created [0 by default].</li>

					<li><strong>upperBound</strong> : EInt. Maximal diagrams number that can be created [-1 by default].</li>

				</ul>

			</li>

		</ul>

		
		<p class="h4">2.2.4 PartConfiguration, NodePartConfiguration and EdgePartConfiguration</p>

		<p>
			There are two types of PartConfiguration. This element will
			describe the graphical representation of an
			ObjectConfiguration defined at the DiagramConfiguration
			level.
		</p>

		<p>
			The NodePartConfiguration is used to describe an object that
			will be represented as a Node in the diagram. You will have
			to specify its graphical properties and also its behavior in
			the editor (whether it is resizable, whether it will
			contains other Nodes, how it will arrange them, ...)
		</p>

		<p>
			The EdgePartConfiguration is used to describe an object that
			will be represented as an Edge in the diagram. It will be
			used to connect two Nodes.
		</p>

		<br /><ul>
			<li>PartConfiguration
				<br /><ul>
					<li><strong>object</strong>: ObjectConfiguration (the model object configuration).</li>

					<li><strong>defaultForegroundColor</strong> : EString. Specify the default foreground color.</li>

					<li><strong>foregroundColorChangeable</strong> : EBoolean. Sspecify if the foreground Color of the figure is changeable.</li>

					<li><strong>fontChangeable</strong> : EBoolean. Specify if the font of the text is changeable.</li>

					<li><strong>prefix</strong> : EString <var class="varname">(since 0.10.0)</var>. The prefix that should be used in the generation process. By default, if the ObjectConfiguration is
						associated with a model object, the prefix is set as the name of the GenClass, otherwise it is initialized with the name given to the SimpleObjectConfiguration.
						This property has been added at the same time of the Constraint, because Constraints allow to associate several graphical objects with a single model object.
					</li>

					<li><strong>* constraint</strong> &gt; Constraint <var class="varname">(since 0.10.0)</var>. Specify the constraints that the model object should check to be valid.</li>

				</ul>

			</li>

		</ul>

		<br /><ul>
			<li>NodePartConfiguration &gt; PartConfiguration
				<br /><ul>
					<li><strong>type</strong> : EString. Specify a Figure that will be extended.</li>

					<li><strong>* childElements</strong> : NodePartConfiguration. Indicates which nodes may be contained by this node.</li>

					<li><strong>superType</strong> : NodePartConfiguration. Specify if the EditPart extends another EditPart.</li>

					<li><strong>defaultWidth</strong> : EInt. Set the default width of the Node (-1 if automatic size).</li>

					<li><strong>defaultHeight</strong> : EInt. Set the default height of the Node (-1 if automatic size).</li>

					<li><strong>minimumWidth</strong> : EInt. Set the minimum width of the Node (-1 if automatic size).</li>

					<li><strong>minimumHeight</strong> : EInt. Set the minimum height of the Node (-1 if automatic size).</li>

					<li><strong>maximumWidth</strong> : EInt. Set the maximum width of the Node (-1 if automatic size and 0 if infinite).</li>

					<li><strong>maximumHeight</strong> : EInt. Set the maximum height of the Node (-1 if automatic size and 0 if infinite).</li>

					<li><strong>defaultBackgroundColor</strong> : EString. Specify the default background color.</li>

					<li><strong>backgroundColorChangeable</strong> : EBoolean. Specify if the background Color of the figure is changeable.</li>

					<li><strong>resizing</strong> : ResizableType. Specify the type of policy that is applicable for this element.</li>

					<li><strong>container</strong> : EBoolean. Specify if the node should act as a container (if it should contain other nodes).</li>

					<li><strong>layout</strong> : LayoutType. Specify the type layout for displaying child nodes.</li>

					<li><strong>directEditable</strong> : EBoolean. Specify if the node has a Label that is DirectEditable.</li>

				</ul>

			</li>

		</ul>

		<br /><ul>
			<li>EdgePartConfiguration &gt; PartConfiguration
				<br /><ul>
					<li><strong>* sourceTargetCouple</strong> &gt; SourceTargetCouple. Define which Nodes can be connected and how.</li>

					<li><strong>* edgeObjects</strong> &gt; EdgeObject. Define the different objects (Label for the moment) that are attached to the connection.</li>

					<li><strong>sourceDecoration</strong> : DecorationType. Specify the type of decoration that should appear at the source of the connection.</li>

					<li><strong>targetDecoration</strong> : DecorationType. Specify the type of decoration that should appear at the target of the connection.</li>

					<li><strong>defaultRouter</strong> : RouterType. Specify the type of Router that should be used for this type of connection.</li>

					<li><strong>directEditable</strong> : EdgeObject. Specify which EdgeObject is DirectEditable.</li>

				</ul>

			</li>

		</ul>

		<p><strong>Remark :</strong> for each NodePartConfiguration, you must specify the figure that will represent the graphical object. You can define your own figures and reference them trough
			an extension by using the extension point (figureDeclaration) defined in the configurator.
		</p>

		
		<p class="h4">2.2.5 PaletteConfiguration, PaletteCategory and PaletteItem</p>

		<p>The PaletteConfiguration is used to configure the tools that will be available in a given diagram. It is composed of several PaletteCategory objects.</p>

		<p>The PaletteCategory is used to arrange the different tools associated with PartConfigurations of the Editor. It contains PaletteItem objects.</p>

		<p>The PaletteItem links a tool with a PartConfiguration. This is the object that will be created from this ToolType.</p>

		<br /><ul>
			<li>PaletteConfiguration
				<br /><ul>
					<li><strong>name</strong> : EString. The name of Palette.</li>

					<li><strong>* paletteCategories</strong> &gt; PaletteCategory. The different categories of the palette.</li>

				</ul>

			</li>

		</ul>

		<br /><ul>
			<li>PaletteCategory
				<br /><ul>
					<li><strong>name</strong> : EString. The name of the category that will be displayed in the editor : "Objects".</li>

					<li><strong>* items</strong> &gt; PaletteItem. The items that will be associated with this category.</li>

				</ul>

			</li>

		</ul>

		<br /><ul>
			<li>PaletteItem
				<br /><ul>
					<li><strong>name</strong> : EString. The name of the Palette item that will be displayed in the editor.</li>

					<li><strong>part</strong> : PartConfiguration. The part that will be created from this item. The type of the tool is determined by the type of the partConfiguration
						(NodePartConfiguration or EdgePartConfiguration).
					</li>

				</ul>

			</li>

		</ul>

		
		<p class="h4">2.2.6 SourceTargetCouple</p>

		<p>
			This defines the source and target couples for each
			connection that can be created. At this point, you will
			define the different possible ways to create an Edge between
			two Nodes. You will then define where the model object will
			be stored in the model and the different references between
			the source Node, the target Node and the Edge. To add a
			"source target couple" to your edge part, right click on the
			part and choose, "New Child &gt; Source target couple".
		</p>

		<br /><ul>
			<li>SourceTargetCouple &gt; PartConfiguration
				<br /><ul>
					<li><strong>autoRef</strong> : EBoolean. If the source and the target can be the same.</li>

					<li><strong>reversible</strong> : EBoolean. If the connection can be inversed (target as a source and source as a target).</li>

					<li><strong>sourceNode</strong> : NodePartConfiguration. The node that can be the source.</li>

					<li><strong>targetNode</strong> : NodePartConfiguration. The node that can be the target.</li>

					<li><strong>containerType</strong> : EdgeContainerType. Define where the connection will be stored.</li>

					<li><strong>containerObject</strong> : GenClass. The object that will contain the connection.</li>

					<li><strong>containerRef</strong> : EStructuralFeature. The feature that will contain the connection.</li>

					<li><strong>refEdgeToSource</strong> : EStructuralFeature. Specify the EStructuralFeature of the Edge that reference the source Node.</li>

					<li><strong>refEdgeToTarget</strong> : EStructuralFeature. Specify the EStructuralFeature of the Edge that reference the target Node.</li>

					<li><strong>refSourceToEdge</strong> : EStructuralFeature. Specify the EStructuralFeature of the source Node that reference the Edge.</li>

					<li><strong>refSourceToTarget</strong> : EStructuralFeature. Specify the EStructuralFeature of the source Node that reference the target Node.</li>

					<li><strong>refTargetToEdge</strong> : EStructuralFeature. Specify the EStructuralFeature of the target Node that reference the Edge.</li>

					<li><strong>refTargetToSource</strong> : EStructuralFeature. Specify the EStructuralFeature of the target Node that reference the source Node.</li>

				</ul>

			</li>

		</ul>

		<p>
			To illustrate this section, we will configure the
			Implementation Edge of the UML2.0 metamodel (An
			Implementation is a specialized Realization relationship
			between a Classifier and an Interface) :
		</p>

		<br /><ul>
			<li><strong>Auto Ref :</strong> a boolean value is required here to indicate if the the same object can be the source and the target of the edge. In this case, it is not an
				auto-reference.
				<var class="varname">Example : In our example, choose false.</var>
			</li>

			<li><strong>Reversible :</strong> a boolean value is required here to indicate if the source can be the target and the target can be the source.
				<var class="varname">Example : In our example, choose false.</var>
			</li>

			<li><strong>SourceNode :</strong> select the node that can be a source for this edge.
				<var class="varname">Example : In our example, the implementation edge has a source of Class type. So, choose the node that represent a Class.</var>
			</li>

			<li><strong>TargetNode :</strong> select the node that can be a target for this edge.
				<var class="varname">Example : In our example, the implementation edge has a target of Interface type. So, choose the node that represent an Interface.</var>
			</li>

			<li><strong>Container Type :</strong> Define where the edge model object is stored
				Available values :
				<br /><ul>
					<li>NONE : the edge has no model object associated (case of the Inheritance link)</li>

					<li>DIAGRAM : the edge is stored in the model object represented by the current diagram.</li>

					<li>SOURCE_CONTAINER : the edge is stored in the model object that stores the source model object</li>

					<li>TARGET_CONTAINER : the edge is stored in the model object that stores the target model object</li>

					<li>SOURCE : the edge is stored in the source model object</li>

					<li>TARGET : the edge is stored in the target model object</li>

				</ul>

				<var class="varname">Example : In our example, the implementation edge is stored in the source model object (the Classifier). So, choose the SOURCE value.</var>
			</li>

			<li><strong>Container Object :</strong> After choosing the container type, if you have chosen a container (different of NONE), you will have to indicate to the configurator the kind
				of model object the container is. This will help to filter the valid features that could handle the edge.
				<var class="varname">Example : In our example, the implementation edge is stored in the source model object. So, you have to choose the object "Classifier".</var>
			</li>

			<li><strong>Container Ref :</strong> This is the feature of the selected container object that will store the edge.
				<var class="varname">Example : Previously, you have chosen the "Classifier" object : so the list shows only the features that are valid. So you have to choose the feature "implementation".</var>
			</li>

			<li><strong>refEdgeToSource, refEdgeToTarget, refSourceToEdge, refSourceToTarget, refTargetToEdge and refTargetToSource :</strong> Here you can specify for each model object implied in
				the edge creation, which feature are used to reference other objects. This will be used at the creation of the model object when all references will be updated.
				<var class="varname">Example : In our example, the feature that will reference the target object, is on the implementation edge itself. It's the "contract" feature. You will have then
					to fill the refEdgeToTarget attribute.
				</var>
			</li>

		</ul>

		<p><strong>Remark :</strong> Repeat all those steps for each "source target" couples.</p>

		
		<p class="h4">2.2.7 EdgeObject</p>

		<p>
			The EdgeObject is used to define which are the different Labels that will be associated with an Edge. In the case of an Association in UML2, we will be able to define two Labels at the source (one for the Cardinality of the Association and the
			other for the name of the reference), two others at the end of the Edge and eventually one at the middle of the Association that will display the name of the current Association. This is a particular example where multiple labels are defined.
		</p>

		<p>
			But in most case, a simple Label will be sufficient. You will be able to define where the Label should be attached (with the type attribute), and select the eStructuralFeature that will be associated with the Label (the feature should
			be of type EString to be well displayed). If the feature is not a direct attribute of the Edge, you will have the possibility to define the id to use : this will be then used at the generation process to create a method used to
			retrieve the EdgeObject. In this case, it is better to set the id as the name of the feature that will be retrieved during the customization step.
		</p>

		<br /><ul>
			<li>EdgeObject
				<br /><ul>
					<li><strong>type</strong> : EdgeObjectType. Define where the EdgeObject should be attached.</li>

					<li><strong>eStructuralFeature</strong> : EStructuralFeature. Define the feature of the Edge model object that should be displayed.</li>

					<li><strong>id</strong> : EString. A required feature, that will be used to generate methods used to retrieve the label that should be displayed. If the eStructuralFeature 	is defined, the id value will automatically be filled with the name of the eStructuralFeature.</li>

				</ul>

			</li>

		</ul>

		
		<p class="h4">2.2.8 Constraint <var class="varname">(since 0.10.0)</var></p>

		<p>
			A Constraint is used to specify a constraint or a set of constraints that should be matched by a PartConfiguration to be valid, and more precisely by the model object associated
			with the ModelObjectConfiguration. Indeed a given model object may represent two different notions depending on its properties. The constraints are then used to check these
			properties at the runtime and specify which PartConfiguration should be used. At the moment, there is only one type of language which is supported : "ocl". You
			can easily add new languages through an extension using the extension point (evaluators) defined in the "org.topcased.modeler" plugin.
		</p>

		<br /><ul>
			<li>Constraint
				<br /><ul>
					<li><strong>language</strong> : EString. Define the language in which the rule is expressed.</li>

					<li><strong>rule</strong> : EString. The rule that will be evaluated at the runtime to check the corresponding EditPart.</li>

				</ul>

			</li>

		</ul>

		
		<p class="h4">2.2.9 Configurator Annotations <var class="varname">(since 0.10.0)</var></p>

		<p>Annotations are generally used to insert additional informations that will be embedded in the configurator model and that will be used during the generation process. An Annotation is composed of one or several detail entries.</p>

		<br /><ul>
			<li>EAnnotation
				<br /><ul>
					<li><strong>source</strong> : EString. For the moment, only one type of Annotation has been defined : "codeCustom". It will define a java customization that will be directly inserted in the generated code.</li>

				</ul>

			</li>

			<li>Detail Entry
				<br /><ul>
					<li>
						<strong>key</strong> : EString. Define the type of customization. It will then be used in the templates to determine at which place the code should be inserted. For the
						moment, only one value is managed : "initModelObject". It corresponds to an Annotation associated with a PaletteItem, and the java code associated will be
						generated at a special place in the generated code.
					</li>

					<li><strong>value</strong> : EString. A java code snippet that must be in accordance with the key.</li>

				</ul>

			</li>

		</ul>

		<p><strong>Remark</strong> : When a new type of code customization is interesting to manage directly in the configurator model, the template(s) associated should be modified to manage it.</p>

		
		<p class="h2" id="mfgeneditor__title3"><a name="mfgeneditor__title3"><!-- --></a>3. Generation of the graphical editor and customizations</p>

		<p>
			When you have finished to configure your editor, you can right click on your configurator file and select the corresponding action : "Topcased &gt; Generation &gt; <strong>Editor</strong>"
			or "Topcased &gt; Generation &gt;	<strong>Diagram</strong>". It will generate a plugin according to the properties you defined in the configurator file.
		</p>

		<p>Once the graphical editor plugin generated, you should be able to run it. However, the editor should be customized to get a more convivial one.</p>

		<p>
			<strong>Remark</strong> : if you modify an attribute or a method that contains a '<strong>@generated</strong>' tag in a generated class, be sure to place '<strong>NOT</strong>' after it to prevent it from
			being overwritten. Note that it is preferable to create '<strong>@generated NOT</strong>' tags, rather than removing the '@generated' tag completely.
		</p>

		
		<p class="h3" id="mfgeneditor__title3.1"><a name="mfgeneditor__title3.1"><!-- --></a>3.1 Icons</p>

		<p>
			The folder called "icons" contains the icons that are used by the editor. These icons are retrieved by an ImageRegistry class : it gets the Image location from the identifier
			that is present in the file <strong>images.properties</strong> that have been generated. After the generation none icon is generated but you can add yours. Just take a look at the
			file image.properties to give the corresponding name to your icons, or rename the file access in the file. Icons used in the palette should be sized to 16x16 to be well displayed.
		</p>

		
		<p class="h3" id="mfgeneditor__title3.2"><a name="mfgeneditor__title3.2"><!-- --></a>3.2 Templates</p>

		<p>The generated editor provides an extension point to define templates. The template files are constrained :</p>

		<br /><ul>
			<li>One template for each type of diagram is required. It is used for example when the user create a new diagrams model from an existing model.</li>

			<li>The parameters of the extension point :
				<br /><ul>
					<li><strong>id :</strong> it is the same field as "presentation" in the editor configuration</li>

					<li><strong>type :</strong> the same field as "prefix" in the editor configuration. It is used to make a filter on the Templates that must be displayed in the wizard comboBox.</li>

					<li><strong>name :</strong> the string displayed in the wizard comboBox</li>

					<li><strong>model :</strong> the model file</li>

					<li><strong>diagrams :</strong>the diagrams model file</li>

				</ul>

			</li>

			<li>They must be called %name%.<strong>xxx</strong> and %name%.<strong>xxxdi</strong>, because this variable is then used by the wizard to name the diagram of the models you will create after.</li>

		</ul>

		<p><strong>Remarks :</strong></p>

		<br /><ul>
			<li>Since the 0.9.0 version of Topcased, a first simple template is generated : it is composed of a single root model object that will be associated with a given diagram.</li>

			<li>As the templates were not generated in the 0.8.0 and older version of Topcased, you had to create them yourself. Fortunately, there is an easy way to do that :
				<br /><ul>
					<li>Create a new model file with the EMF tree structure editor and call it "%name%".</li>

					<li>Then select the corresponding root object in the EMF wizard and click on finish.</li>

					<li>The tree structure editor is then open. You can save your model and close the editor. This model will be used as the template of the model file. So you have to copy
						it in the directory "templates/template1/%name%.<strong>xxx</strong>" of your generated Topcased plugin (you have to create the directory "template1" that was not generated).
					</li>

					<li>Then you will have to create the template for the diagram file. So create a new diagram file from an existing model file. There you will have to reference the file
						%name%.my as the existing model file, select the root object that will be associated with the diagram and click on finish. Now the file "%name%.<strong>xxxdi</strong>"
						should be created. Copy it in the directory	"templates/template1/%name%.<strong>xxxdi</strong>" and then, you should be able to create new models from the template associated
						with the diagram.
					</li>

				</ul>

			</li>

			<li>At least one template is associated for each diagram. The first diagram will retrieve its templates in the directory "templates/template1/" of the generated plugin. The
				second diagram will then retrieve its templates from the directory "templates/template2/", ... You can have a look at the plugin.xml file to retrieve the different
				templates associated with the different Diagrams of the model.
			</li>

		</ul>

		
		<p class="h3" id="mfgeneditor__title3.3"><a name="mfgeneditor__title3.3"><!-- --></a>3.3 EditPart customization</p>

		<p>
			The EditParts are the controller objects of the editor. They are used to link the model object with its graphical representation. There is mainly one method to customize : the
			<strong>createEditPolicies()</strong> method. This is the method that configure the behavior of the graphical node or edge. Lots of information is generated but you can add new behaviors.
		</p>

		
		<p class="h3" id="mfgeneditor__title3.4"><a name="mfgeneditor__title3.4"><!-- --></a>3.4 Figure customization</p>

		<p>The "Figures" manage the graphical aspect, that is how an object of the model should be displayed.</p>

		<br /><ul>
			<li>You can define some figures that you will later reference during the "Editor Configuration step" : the generated figures will inherit from these basic figures.</li>

			<li>You can also customize directly the generated Figure. Generally, the <strong>paintFigure()</strong> and the <strong>paintBorder()</strong> methods may be overridden to define the desired shape of the Figure.</li>

		</ul>

		
		<p class="h3" id="mfgeneditor__title3.5"><a name="mfgeneditor__title3.5"><!-- --></a>3.5 TODO tags</p>

		<p>
			When the editor is generated, there are some code that must be customized or that will certainly be customized. So in the generated code, we introduce some TODO tags so that the
			developer that will have to customize the code can accede faster to the code that need some customization. There is a dedicated view in Eclipse (The Task view) that references
			all the TODO tags present in the java files.
		</p>

		<img src="images/generateEditor/todo.jpg" alt="todo" />
		<p>So, in the most cases, you will have to open the Tasks view to see the TODO tags that will help you to find where some code should be handle coded.</p>

		
		<p class="h3" id="mfgeneditor__title3.6"><a name="mfgeneditor__title3.6"><!-- --></a>3.6 The diagram.graphconf file <var class="varname">(since 0.9.0)</var></p>

		<p>
			This file contains the graphical informations (colors, size,...) used to display graphical elements in a given diagram. Previously, these informations were generated in the java classes, but these informations were often duplicated in
			many classes to be always accessible. Now, these informations are stored in a unique place and are accessed in a unique way.
		</p>

		<p>
			The file is generated from the informations present in the diagram configuration file. It is not recommended to modify this file : the better way would consist in updating the diagram.configuration file and regenerating the diagram
			plugin (with the option "overwriteGraphConf" set to true).
		</p>

		
		<p class="h4">By Jacques LESCOT, Anyware Technologies</p>

		<p class="h4">Updated June, 26 2006</p>

		
	</div>


</body>
</html>